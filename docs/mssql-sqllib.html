<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>MSSQL::Sqllib</title>
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#overview">OVERVIEW</a></li>
	<li><a href="#export_tags">EXPORT TAGS</a></li>
	<li><a href="#function_descriptions">FUNCTION DESCRIPTIONS</a></li>
	<ul>

		<li><a href="#summary">Summary</a></li>
		<li><a href="#sql_init">sql_init</a></li>
		<li><a href="#sql">sql</a></li>
		<li><a href="#sql_one">sql_one</a></li>
		<li><a href="#sql_sp">sql_sp</a></li>
		<li><a href="#sql_insert">sql_insert</a></li>
		<li><a href="#sql_string">sql_string</a></li>
		<li><a href="#transaction_routines">Transaction routines</a></li>
		<li><a href="#sql_set_conversion">sql_set_conversion</a></li>
		<li><a href="#sql_unset_conversion">sql_unset_conversion</a></li>
		<li><a href="#sql_message_handler">sql_message_handler</a></li>
		<li><a href="#sql_error_handler">sql_error_handler</a></li>
	</ul>

	<li><a href="#handle_attributes">HANDLE ATTRIBUTES</a></li>
	<ul>

		<li><a href="#misc_attributes">Misc attributes</a></li>
		<li><a href="#errinfo">errInfo</a></li>
	</ul>

	<li><a href="#restrictions_with_new_datatypes">Restrictions with new datatypes</a></li>
	<li><a href="#acknowledgements">ACKNOWLEDGEMENTS</a></li>
	<li><a href="#author">AUTHOR</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>MSSQL::Sqllib - SQL Library for Microsoft SQL Server from Perl</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
   use MSSQL::Sqllib;</pre>
<pre>
   use MSSQL::Sqllib qw(:DEFAULT :consts);</pre>
<pre>
   use MSSQL::Sqllib qw(:DEFAULT [:resultstyles] [:rowstyles] [:directions]
                                 [:returns] [$SQLSEP]);</pre>
<p>
</p>
<hr />
<h1><a name="overview">OVERVIEW</a></h1>
<p>MSSQL::Sqllib is a Perl module that inherits from <a href="././mssql-dblib.html#mssql::dblib">MSSQL::DBlib in the mssql-dblib manpage</a>
and extends it with a high-level interface, providing the possibility to send
an SQL command and retrieve the result in one line of code and forget about
error-checking. By default MSSQL::Sqllib will abort in case of a error, be
it in DB-Library or SQL Server. The result set(s) from the SQL query can
be received by callback or in a return value which can be structured in several
ways, ranging from one single scalar up to a three-dimensional array, or in a hash
with keyed with key values in the data.</p>
<p>There are also special calls for single-row queries, for generating INSERT
statements from a hash, and generating code for calling stored procedures and
retrieve output parameters.</p>
<p>MSSQL::Sqllib has a configurable message handler for SQL errors, permitting
you to choose which errors you tolerate and which you do not. You can opt to
get the errors messages sent back to you and/or have them printed on STDERR.
A similar arrangement exists for handling DB-Library errors.</p>
<p>MSSQL::Sqllib also provides the possibility to chose your own character
conversion much more freely than Microsoft's ANSI/OEM concept permits.</p>
<p>For special tasks, you have access to all calls in MSSQL::DBlib.</p>
<p>A simple example of using this module:</p>
<pre>
      use MSSQL::Sqllib;</pre>
<pre>
      # Log into the server.
      my $X = sql_init(&quot;&quot;, &quot;sa&quot;, &quot;&quot;, &quot;master&quot;);</pre>
<pre>
      # Run a query.
      @x = $X-&gt;sql(&quot;SELECT dbid, name, crdate FROM sysdatabases&quot;);</pre>
<pre>
      # Just print the results, it's a list of hashes.
      foreach $x (@x) {
        foreach $kol (keys %$x) {
           print &quot;$kol: $$x{$kol}   &quot;;
        }
        print &quot;\n&quot;;
      }</pre>
<p>Since MSSQL::Sqllib is based on DB-Library, and Microsoft is no longer
developing DB-Library, this means that with MSSQL::Sqllib you do not have
access to all features in SQL7 and SQL2000. See the section <a href="#restrictions_with_new_datatypes">Restrictions with new datatypes</a> at the end of this document. Thus, you should not
use MSSQL::Sqllib, unless you are certain that the restrictions will not
be an issue for you.</p>
<p>If you want to use MSSQL::Sqllib in a threaded environment, the short story
is that you <em>cannot</em> use it with <code>use threads</code> in a Perl script, but you can
use it in an environment for a thing like ActiveState's PerlScript. Please
see further <a href="././mssql-dblib.html#notes_on_threading_and_perlscript">Notes on threading and PerlScript in the mssql-dblib manpage</a>.</p>
<p>
</p>
<hr />
<h1><a name="export_tags">EXPORT TAGS</a></h1>
<p>By default MSSQL::Sqllib exports a couple of routines. They are described
in the section <a href="#function_descriptions">FUNCTION DESCRIPTIONS</a>.</p>
<p>MSSQL::Sqllib also exports a number of constants that are used in the
interface of the routines. To avoid clashes with other modules, they are not
exported by default. You can request these being imported by mentioning them
in your <code>use</code> statement, either by mentioning them explicitly, or using any
the following export tags below. Don't forget that export tags must be
preceded by a colon, see the <a href="#synopsis">SYNOPSIS</a>.</p>
<dl>
<dt><strong><a name="item_default">DEFAULT</a></strong><br />
</dt>
<dd>
This tag imports all routines in MSSQL::Sqllib, but no constants. You need
to use this tag when you add other items to the import list, since as soon as
you have an explicit list, nothing is imported by default.
</dd>
<p></p>
<dt><strong><a name="item_consts">consts</a></strong><br />
</dt>
<dd>
Imports all constants, as well as <code>$SQLSEP</code>, the only control variable
in MSSQL::Sqllib. (In fact it is quite much of a constant, save the
fact that you can change it. :-)
</dd>
<p></p>
<dt><strong><a name="item_resultstyles">resultstyles</a></strong><br />
</dt>
<dd>
Imports these five constants: <a href="#item_noresult"><code>NORESULT</code></a>, <a href="#item_singlerow"><code>SINGLEROW</code></a>, <a href="#item_singleset"><code>SINGLESET</code></a>, <a href="#item_keyed"><code>KEYED</code></a> and
<a href="#item_multiset"><code>MULTISET</code></a>. You use them to choose how the results from an SQL batch are to
be structured on Perl level.
</dd>
<p></p>
<dt><strong><a name="item_rowstyles">rowstyles</a></strong><br />
</dt>
<dd>
Imports these three constants: <a href="#item_scalar"><code>SCALAR</code></a>, <a href="#item_list"><code>LIST</code></a> and <a href="#item_hash"><code>HASH</code></a>. You use them
to choose how the rows in a result set is to be represented.
</dd>
<p></p>
<dt><strong><a name="item_directions">directions</a></strong><br />
</dt>
<dd>
Imports these three constants: <a href="#item_to_server_only"><code>TO_SERVER_ONLY</code></a>, <a href="#item_to_client_only"><code>TO_CLIENT_ONLY</code></a> and
<a href="#item_to_server_client"><code>TO_SERVER_CLIENT</code></a>. You use them with the configuration routines
<a href="#sql_set_conversion">sql_set_conversion</a> and <a href="#sql_unset_conversion">sql_unset_conversion</a>.
</dd>
<p></p>
<dt><strong><a name="item_returns">returns</a></strong><br />
</dt>
<dd>
Imports these five constants: <a href="#item_return_nextrow"><code>RETURN_NEXTROW</code></a>, <a href="#item_return_nextquery"><code>RETURN_NEXTQUERY</code></a>,
<a href="#item_return_cancel"><code>RETURN_CANCEL</code></a>, <a href="#item_return_error"><code>RETURN_ERROR</code></a> and <a href="#item_return_abort"><code>RETURN_ABORT</code></a>. You use them for
return values from callback routines.
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><a name="function_descriptions">FUNCTION DESCRIPTIONS</a></h1>
<p>
</p>
<h2><a name="summary">Summary</a></h2>
<p><a href="#sql_init">sql_init</a> sets up message and error handlers, logs into the server,
sets up defaults and returns a blessed reference.</p>
<p><a href="#sql">sql</a> runs a batch of one or more SQL queries and returns the result which
can be structured in the way of your choice. Alternatively, <a href="#sql">sql</a> can send the
results row by row to a user-provided callback routine. By default, if an
error occurs, <a href="#sql">sql</a> will abort the Perl script.</p>
<p><a href="#sql_one">sql_one</a> runs an SQL query that is supposed to return exactly one row,
and <a href="#sql_one">sql_one</a> will abort if the query does not.</p>
<p><a href="#sql_sp">sql_sp</a> calls a stored procedure with named or unnamed parameters and retrieves
the result sets, the return value and any output parameters of the SP.</p>
<p><a href="#sql_insert">sql_insert</a> generates an INSERT statement from a hash and executes the
statement.</p>
<p><a href="#sql_begin_trans">sql_begin_trans</a>, <a href="#sql_commit">sql_commit</a>, <a href="#sql_rollback">sql_rollback</a> begin and end
transactions.</p>
<p><a href="#sql_string">sql_string</a> formats a string to use in an SQL statement.</p>
<p><a href="#sql_set_conversion">sql_set_conversion</a> sets up a conversion from one character-set to
another. The conversion may be bi-directional, or only from client to
server or vice versa.</p>
<p><a href="#sql_unset_conversion">sql_unset_conversion</a> removes a conversion in force.</p>
<p><a href="#sql_message_handler">sql_message_handler</a> is a configurable handler for SQL Server messages.</p>
<p><a href="#sql_error_handler">sql_error_handler</a> is a configurable handler for DB-Library errors.</p>
<p>
</p>
<h2><a name="sql_init">sql_init</a></h2>
<pre>
    $X = sql_init([$server [, $user [, $password [, $database]]]]);
    $X = new MSSQL::Sqllib [$server, [$user [, $password [, $database]]]];</pre>
<p><a href="#sql_init">sql_init</a> logs into SQL Server, and performs a number of initializations
listed below. <strong>new</strong> simply calls <a href="#sql_init">sql_init</a>.</p>
<p>The following defaults apply for the parameters:</p>
<p><strong>$server</strong>: the server on the local machine.</p>
<p><strong>$user</strong>: <em>sa</em>.</p>
<p><strong>$password</strong>: NULL.</p>
<p><strong>$database</strong>: the user's default database as defined in SQL Server, with
one exception: for <em>sa</em>, the database will be <em>tempdb</em> to avoid a disaster,
were you to accidently omit <code>$database</code>.</p>
<p>To use <strong>Windows NT authentication</strong> (known as ``integrated security'' MS SQL 6.5),
call the MSSQL::DBlib routine <a href="././mssql-dblib.html#dbsetlsecure">DBSETLSECURE in the mssql-dblib manpage</a> before you call
<a href="#sql_init">sql_init</a>.</p>
<p>The following initializations are performed:</p>
<ul>
<li></li>
The first time <a href="#sql_init">sql_init</a> is called, it will establish
<a href="#sql_message_handler">sql_message_handler</a> and <a href="#sql_error_handler">sql_error_handler</a> as message and error
handlers. On further calls, the then-current handlers will be retained.
<p></p>
<li></li>
Sets the attributes <a href="././mssql-dblib.html#item_dateformat"><code>dateFormat</code></a> and <a href="././mssql-dblib.html#item_msecformat"><code>msecFormat</code></a> to <code>%Y%m%d %H:%M:%S</code> and
<code>.%3.3d</code> respectively, giving a default representation for datetime values
in the style of ``19980106 13:29:19.230''.
<p></p>
<li></li>
Turns of any ANSI/OEM conversion that may be in effect. See <a href="#sql_set_conversion">sql_set_conversion</a>
if you wish to use character-set conversion.
<p></p></ul>
<p>If any error occurs while setting up the connection, <a href="#sql_init">sql_init</a> will abort
execution. This includes errors that are not considered fatal by SQL Server,
such as the user's default database in SQL Server not being accessible. (If
you need to continue after a failed login, remember that you can always run
your <a href="#sql_init">sql_init</a> from an <code>eval</code>.)</p>
<p><strong>$server</strong> may refer to a named instance, for instance MYMACHINE\SECOND.
Officially, Microsoft does not support named instances in DB-Library, but
it appears they changed DB-Library to handle it nevertheless. If you run
into to problems, use the Client Network Utility and set up an alias for
the named instance.</p>
<p>The return value from <a href="#sql_init">sql_init</a> is a blessed reference to a hash, in this
document usually called a <em>handle</em>. The handle that is created the first time
<a href="#sql_init">sql_init</a> is called becomes the default handle for calls to other routines
in MSSQL::Sqllib. This is conventient in throw-away scripts, but for serious
development, I recomment that you always use a handle when you access the
other routines. You often need to use the handle anyway, to change the
attributes, particularly <a href="#errinfo">errInfo</a>. In the syntax descriptions below, the
handles are shown as mandatory.</p>
<p><strong>NOTE:</strong> If you use MSSQL::Sqllib from a thing like ActiveState's PerlScript
you must always use the handle.</p>
<p>
</p>
<h2><a name="sql">sql</a></h2>
<pre>
    $resultref = $X-&gt;sql($sql [, $rowstyle] [, $resultstyle]]);
    @result    = $X-&gt;sql($sql [, $rowstyle] [, $resultstyle]]);
    %result    = $X-&gt;sql($sql, HASH, SINGLEROW);</pre>
<pre>
    $hashref   = $X-&gt;sql($sql [, $rowstyle], KEYED, \@keys);
    %hash      = $X-&gt;sql($sql [, $rowstyle], KEYED, \@keys);</pre>
<pre>
    $retstat   = $X-&gt;sql($sql [, $rowstyle], \&amp;callback);</pre>
<p><strong>$X</strong> is the handle that you got when you called <a href="#sql_init">sql_init</a>.</p>
<p><strong>$sql</strong> is a string containing one
or more SQL statements. <a href="#sql">sql</a> executes them as one batch (thus you cannot
separate batches with <em>go</em>), and in case of success returns the result set.</p>
<p>By default, if SQL Server or DB-Library signals an error, execution is aborted.
You can alter this behaviour with the various elemetns of the handle attribute
<a href="#errinfo">errInfo</a>. See this attribute for details.</p>
<p>For details on how the various data types in SQL Server are returned, see
the MSSQL::DBlib routine <a href="././mssql-dblib.html#dbnextrow2">dbnextrow2 in the mssql-dblib manpage</a>.</p>
<p>The data from SQL Server can be structured in several different ways, as determined
by the parameters <code>$rowstyle</code> and <code>$resultstyle</code>, as detailed below. Below I say
that the return value for a certain combination is a scalar, array or a hash. In every
case when I say array or hash, you can always opt for receiving the return
value in a scalar to get a reference to that array/hash.</p>
<p>In the call syntax above, <code>$rowstyle</code> is shown as coming before <code>$resultstyle</code>.
However, <a href="#sql">sql</a> actually permits you to put <code>$rowstyle</code> after <code>$resultstyle</code>.
This is also true when <code>$resultstyle</code> is KEYED or <code>\&amp;callback</code>. However,
<code>$rowstyle</code> must come before <code>\@keys</code>.</p>
<p><strong>Row style</strong></p>
<p><strong>$rowstyle</strong> controls how each row is to appear at the lowest level of the
result. There are three possible values:</p>
<dl>
<dt><strong><a name="item_hash">HASH</a></strong><br />
</dt>
<dd>
Each row is returned as a hash with the column names as keys. Nameless columns
are called <em>Col 1</em>, <em>Col 2</em> etc. This is the default row style.
</dd>
<dd>
<p>If more than one column in a result set has the same name, only one of them
will be present in the result set. If warnings are active, you will receive
a warning about this condition.</p>
</dd>
<p></p>
<dt><strong><a name="item_list">LIST</a></strong><br />
</dt>
<dd>
Each row is returned as an array with the columns appearing in the order they
appeared in the query with the first column at index 0.
</dd>
<p></p>
<dt><strong><a name="item_scalar">SCALAR</a></strong><br />
</dt>
<dd>
Each row is returned as a scalar value. SCALAR is mainly intended for one-columns
queries, but if the query has more than one column, they are separated by the
module attribute <code>$MSSQL::Sqllib::SQLSEP</code>. Initially <code>$SQLSEP</code> has the value
<code>&quot;\022&quot;</code>, a control character. You can set it to a string of any length that
fit your needs. Note, however, that the value of <code>$SQLSEP</code> <em>must not</em> appear
in the actual data.
</dd>
<p></p></dl>
<p><strong>Result styles</strong></p>
<p><strong>$resultstyle</strong> controls how the rows are ``packaged''. There are five possible values:</p>
<dl>
<dt><strong><a name="item_singleset">SINGLESET</a></strong><br />
</dt>
<dd>
The rows are returned in one single array, which thus is an array of hashes,
arrays or scalars depending on <code>$rowstyle</code>. The order of the array is the same
as the order returned from SQL Server. If the batch returns two or more result
sets, these will come after each other in the result set, and you will have to
separate them yourself.
</dd>
<dd>
<p><a href="#item_singleset"><code>SINGLESET</code></a> is the default resultstyle.</p>
</dd>
<p></p>
<dt><strong><a name="item_multiset">MULTISET</a></strong><br />
</dt>
<dd>
You get an array of result sets in the order they come from SQL Server. Each
result set is in its turn an array of hashes, arrays or scalars dependning on
<code>$rowstyle</code>.
</dd>
<p></p>
<dt><strong><a name="item_singlerow">SINGLEROW</a></strong><br />
</dt>
<dd>
The return value is a hash, an array or a scalar with the single row that the
batch is supposed to return.  When you specify <a href="#item_scalar"><code>SCALAR</code></a> and <a href="#item_singlerow"><code>SINGLEROW</code></a>, and
provide a scalar return value, you will get the actual row, not a reference to
a scalar.
</dd>
<dd>
<p>Would the batch return more than one row, or more than one result set, you get
what you get, and it may or may not make sense. See also <a href="#sql_one">sql_one</a>.</p>
</dd>
<p></p>
<dt><strong><a name="item_keyed">KEYED</a></strong><br />
</dt>
<dd>
The return value is a hash keyed with the data in the highest-level key column
in the result set. There can be more than one key level, in which case you
will get one more hash dimension for each key level. In the bottom of the
structure there is a hash, array or scalar, depending on <code>$rowstyle</code>, with the
non-key columns of the result set.
</dd>
<dd>
<p>Which column(s) that supply the key values, is determined by the parameter
<strong>@keys</strong>, which is mandatory for <a href="#item_keyed"><code>KEYED</code></a>. For row style <a href="#item_hash"><code>HASH</code></a>, <code>@keys</code> should
hold the name of the key column(s) of the result set. For row style <a href="#item_list"><code>LIST</code></a>
and <a href="#item_scalar"><code>SCALAR</code></a>, <code>@keys</code> should hold the column number of the key(s). Column numbers
start on 1.</p>
</dd>
<dd>
<p>A simple example, retrieve all types and their ids:</p>
</dd>
<dd>
<pre>
    %types = $X-&gt;sql(&quot;SELECT name, type FROM systypes&quot;, SCALAR, KEYED, [1]);
    foreach $type (keys %types) {
       print &quot;$type:  $types{$type}\n&quot;;
    }</pre>
</dd>
<dd>
<p>A more complicated case. The table Tbl has the columns key1, key2, key3, val1,
val2, ... Among other data, we want to retrive the column val4 for the key
ABC/17/X.</p>
</dd>
<dd>
<pre>
    $result = $X-&gt;sql(&quot;SELECT * FROM Tbl&quot;, HASH, KEYED,
                      ['key1', 'key2', 'key3']);
    $val4 = $$result{'ABC'}{'17'}{'X'}{'val4'};</pre>
</dd>
<dd>
<p>The keys you provide in <code>@keys</code> are supposed to be the unique keys of your result
set, and appear in all rows of the result set(s). If a key listed in <code>@keys</code>
does not appear in one of the rows, this is an error, and <a href="#sql">sql</a> will
unconditionally abort. If a key value is a duplicate, <a href="#sql">sql</a> will emit a warning
about this, if warnings are activated. It is undefined which values that end up in
the result set.</p>
</dd>
<dd>
<p>If one or more of your key columns can hold NULL values, you will get warnings
about uninitialized value from Perl if you run with <code>-w</code>. One way to avoid this
warning, is to set the handle attribute <a href="././mssql-dblib.html#item_dbnullisundef"><code>dbNullIsUndef</code></a> to 0, in which case NULL
values will be received as the string ``NULL'' instead of <code>undef</code>.</p>
</dd>
<p></p>
<dt><strong><a name="item_noresult">NORESULT</a></strong><br />
</dt>
<dd>
The batch is not expected to return any data, or you simply do not care about
it, and wish to save network traffic. The return value is <code>undef</code> or an empty
array.
</dd>
<p></p></dl>
<p>The script <em>sqllib\t\1_resultsets.t</em> can give you an idea of the structure
you get with the various row and result styles.</p>
<p>When there are no result sets in the query at all - which may happen if the batch
does not compile, and you have changed <a href="#errinfo">errInfo</a> so that <a href="#sql">sql</a> does not
abort on errors - you will get <code>undef</code> in return if you specify a scalar return
value. Else you will get an empty list/hash.</p>
<p><strong>Callbacks</strong></p>
<p>Instead of a result style, you can provide a callback. <a href="#sql">sql</a> calls your callback
in this way, depending on <code>$rowstyle</code>:</p>
<pre>
       $retstat = &amp;$callback(\%row, $resultset_no);   # HASH
       $retstat = &amp;$callback(\@row, $resultset_no);   # LIST
       $retstat = &amp;$callback($row,  $resultset_no);   # SCALAR</pre>
<p><strong>$resultset_no</strong> tells you which result set the row comes from. The result
sets are numbered from 1 and up.</p>
<p>The callback should return any of the integer numbers detailed below. The
return value from the last call to the callback is the return value from <a href="#sql">sql</a>.</p>
<dl>
<dt><strong><a name="item_return_nextrow">RETURN_NEXTROW</a></strong><br />
</dt>
<dd>
Tells <a href="#sql">sql</a> to give you the next row (if there is one, that is). This is the
``normal'' return value. I usually don't leak constant values, but if you think
RETURN_NEXTROW is too noisy, I can reveal that <strong>1</strong> will do the same task.
</dd>
<p></p>
<dt><strong><a name="item_return_nextquery">RETURN_NEXTQUERY</a></strong><br />
</dt>
<dd>
Tells <a href="#sql">sql</a> to cancel the current result set, and proceed to the next one.
If there are no more result sets, this is how the story ends.
</dd>
<p></p>
<dt><strong><a name="item_return_cancel">RETURN_CANCEL</a></strong><br />
</dt>
<dt><strong><a name="item_return_error">RETURN_ERROR</a></strong><br />
</dt>
<dd>
From the point of view of <a href="#sql">sql</a> these are the same. The entire batch will
be cancelled and that's it. There are two different values, though, so when
getting the return value from <a href="#sql">sql</a> you can tell them apart. RETURN_CANCEL
probably means that you found what you was looking for. RETURN_ERROR probably
means that something went wrong. RETURN_ERROR conveniently has the value 0.
</dd>
<p></p>
<dt><strong><a name="item_return_abort">RETURN_ABORT</a></strong><br />
</dt>
<dd>
Something went terribly wrong and you don't want to live any more. You want
<a href="#sql">sql</a> to hold the axe though, so it can cancel the query before it aborts.
Useful if <a href="#sql">sql</a> was called from inside an <code>eval</code>.
</dd>
<p></p></dl>
<p>A few goods and bads with callbacks:</p>
<ul>
<li></li>
Good thing: saves you from dealing with multi-dimensional structures, which
can be confusing at times.
<p></p>
<li></li>
Good thing: if you are retrieving a large result set, you don't need to gather
all the data in client before processing them.
<p></p>
<li></li>
(Slightly) bad thing: if you want to execute SQL statements from your
callback, you need to use another handle for that, as DB-Library does not
permit you to intiate a new query as long as there are results sets available.
<p></p>
<li></li>
Bad thing: if the tables are large you may hold a lock on them for a
considerable time. This also means that it is not always a bright to idea to
send an UPDATE on the tables from the callback. As this is done from another
connection, you may in fact end up locking yourself.
<p></p></ul>
<p><strong>COMPUTE BY</strong></p>
<p>If the batch contains COMPUTE BY clauses, the COMPUTE rows will come
interleaved with the regular rows. With the <a href="#item_list"><code>LIST</code></a> and <a href="#item_scalar"><code>SCALAR</code></a> rowstyle
values, you have to do the best you can to tell which is which. With <a href="#item_hash"><code>HASH</code></a>,
though, the COMPUTE rows will have an extra column <strong>COMPUTEID</strong> that holds the
number of the COMPUTE BY clause in the query.</p>
<p>
</p>
<h2><a name="sql_one">sql_one</a></h2>
<pre>
    %result = $X-&gt;sql_one($sql[, HASH]);
    @result = $X-&gt;sql_one($sql, LIST);
    $result = $X-&gt;sql_one($sql[, SCALAR)];</pre>
<p><a href="#sql_one">sql_one</a> is similar to <a href="#sql">sql</a> with the <a href="#item_singlerow"><code>SINGLEROW</code></a> result style. However,
<a href="#sql_one">sql_one</a> requires the SQL batch to return exactly one row, and will abort
execution if no rows were found, or if there were more than one row. The
batch may return more than one result set, but all but one must be empty.</p>
<p>
</p>
<h2><a name="sql_sp">sql_sp</a></h2>
<pre>
   $resultref = $X-&gt;sql_sp($sp [, \$sp_retstat] [, \@params] [, \%params]
                               [, $rowstyle] [, $resultstyle]);
   @result    = $X-&gt;sql_sp($sp [, \$sp_retstat] [, \@params] [, \%params]
                               [, $rowstyle] [, $resultstyle]);
   %result    = $X-&gt;sql_sp($sp [, \$sp_retstat] [, \@params] [, \%params],
                               HASH, SINGLESET);</pre>
<pre>
   $hashref   = $X-&gt;sql_sp($sp [, \$sp_retstat] [, \@params] [, \%params]
                               [, $rowstyle], KEYED, \@keys);
   %hash      = $X-&gt;sql_sp($sp [, \$sp_retstat] [, \@params] [, \%params]
                               [,  $rowstyle], KEYED, \@keys);</pre>
<pre>
   $retstat   = $X-&gt;sql_sp($sp [, \$sp_retstat] [, \@params] [, \%params]
                               [, $rowstyle], \&amp;callback);</pre>
<p><strong>$X</strong> is the handle you got from <a href="#sql_init">sql_init</a>.</p>
<p><a href="#sql_sp">sql_sp</a> calls the stored procedure <strong>$sp</strong> and retrieves the return status of
the SP and values of output parameters. To find out datatypes and output
parameters, <a href="#sql_sp">sql_sp</a> interrogates the server and caches the parameter profile
internally in case the same SP is called again. See the handle attribute <a href="#item_procs"><code>procs</code></a>
for details about caching.</p>
<p>By default, if an error occurs in SQL Server or in DB-Library, or the procedure
returns a non-zero value, execution is aborted. This behaviour is controlled
by various elements the handle attribute <a href="#errinfo">errInfo</a>. See further this attribute.</p>
<p>The various return values of <a href="#sql_sp">sql_sp</a>, as well as the parameters <strong>$rowstyle</strong>,
<strong>$resultstyle</strong>, <strong>&amp;callback</strong>, and <strong>@keys</strong> work exactly in the same way as with
<a href="#sql">sql</a>, please see this routine for details.</p>
<p><strong>\$sp_retstat</strong> is a reference to scalar that is to receive the return status
of the stored procedure. This parameter is only of interest, if you have changed
the <a href="#item_checkretstat"><code>checkRetStat</code></a> or <a href="#item_retstatok"><code>retStatOK</code></a> elements of <a href="#errinfo">errInfo</a> to permit one or more
non-zero return values.</p>
<p><strong>\@params</strong> is a reference to an array that holds unnamed parameters to the
stored procedure in the order as they appear in the procedure declaration. The
array elements can be scalars with the actual parameter values, or references
to scalars that hold the values. Values and references can be mixed. If any
of the parameters is an output parameter, the output value replaces the
input value. When you send in an anonymous array, you need to pass output
parameters as references, or else you will lose the changes. Of this reason
<a href="#sql_sp">sql_sp</a> will emit a warning if warnings are active, when it detects that
an output parameter has been passed as a value. (Yeah, this warning is bogus
if you send in an actual array, but there is no way to tell them apart.) See
also the second of the examples below.</p>
<p><strong>\%params</strong> is a reference to a hash with the keys being names of the
stored-procedure parameter. (Don't forget the <strong>@</strong>.) For the elements
the same issues as for <code>\@params</code> apply.</p>
<p>Notes:</p>
<ul>
<li></li>
If you provide <code>\@param</code> as well as <code>\%param</code>, and the same parameter
appears in both, the value in <code>\@param</code> will be used, and will in fact
overwrite what's in <code>\%param</code>.
<p></p>
<li></li>
It is undefined whether output parameters of the datatypes <em>binary</em> and <em>char</em>
will include trailing zeroes or blanks respectively. This actually depends on which
version of SQL Server you are using.
<p></p>
<li></li>
To pass NULL for a parameter, send <code>undef</code>. <a href="#sql_sp">sql_sp</a> does not consider the
attribute <a href="././mssql-dblib.html#item_dbnullisundef"><code>dbNullIsUndef</code></a>.
<p></p></ul>
<p><strong>Examples</strong></p>
<p><em>sp_helpdb</em> returns two result sets. Here is an example using a callback
that prints out the result sets in a fairly simple manner:</p>
<pre>
       sub print_hash {
          my($hash, $ressetno) = @_;
          my ($col);
          print &quot;$ressetno: &quot;;
          foreach $col (%$hash) {
               print &quot;$col: $$hash{$col} &quot;;
          }
          print &quot;\n&quot;;
          RETURN_NEXTROW;
       }
       $X-&gt;sql_sp(&quot;sp_helpdb&quot;, ['tempdb'], HASH, \&amp;print_hash);</pre>
<p>And here is an example with a procedure that takes two dates as parameters to
count the number of records in that interval. Passing NULL means no limit in
that direction. The SP permits you to restrict the count to records of a
certain flavour. The value is returned in an output parameter. There are
no result sets.</p>
<pre>
     CREATE PROCEDURE putte_sp @startdate datetime = NULL,
                               @enddate   datetime = NULL,
                               @flavour   smallint = NULL,
                               @no_of_rec int      OUTPUT AS</pre>
<p>Say we want to know how many records there are from 1997 and on, of all
flavours, and we also want the return value. In T-SQL the call would be:</p>
<pre>
     EXEC @ret = putte_sp '19970101', @no_of_ref = @no_of_rec OUTPUT</pre>
<p>In MSSQL::Sqllib this translates to:</p>
<pre>
     $X-&gt;{errInfo}{checkRetStat} = 0;
     $X-&gt;sql_sp('putte_sp', \$ret, ['19970101'], {'@no_of_rec' =&gt; \$no_of_rec});</pre>
<p>Notice how we pass a reference to <code>$no_of_rec</code>, rather than the variable
itself, so we can retrieve the output value later on. We also set the
<a href="#item_checkretstat">checkRetStat</a> attribute, as else <a href="#sql_sp">the sql_sp manpage</a> would abort if the return value
was non-zero.</p>
<p>
</p>
<h2><a name="sql_insert">sql_insert</a></h2>
<pre>
   $X-&gt;sql_insert($table, $valref);</pre>
<p><a href="#sql_insert">sql_insert</a> generates an INSERT statement from a hash and executes it.
No data is returned.</p>
<p><strong>$table</strong> is the name of the table, and <strong>$valref</strong> is a reference to a hash
where the name of the keys are taken as column names. <a href="#sql_insert">sql_insert</a>
interrogates the server to find out the datatypes of the table columns.
This profile is cached internally, in case the same table is inserted to again.
See also the handle attributes <a href="#item_tables"><code>tables</code></a>.</p>
<p>For string types, <a href="#sql_insert">sql_insert</a> will put quotes around the values (using
<a href="#sql_string">sql_string</a>) when composing the INSERT statement. For binary datatypes,
<a href="#sql_insert">sql_insert</a> will add add a leading <code>0x</code>, unless a <code>0x</code> is already there.</p>
<p><strong>Notes:</strong></p>
<ul>
<li></li>
To pass NULL for a parameter, send <code>undef</code>. <a href="#sql_insert">sql_insert</a> does not consider the
attribute <a href="././mssql-dblib.html#item_dbnullisundef"><code>dbNullIsUndef</code></a>.
<p></p>
<li></li>
While <a href="#sql_insert">sql_insert</a> is convenient, be aware of that there is a considerable
performane penalty for inserting data to SQL Server with bare SQL statments,
and there is a lot to gain by using stored procedures.
<p></p></ul>
<p>
</p>
<h2><a name="sql_string">sql_string</a></h2>
<pre>
    $string = sql_string($string);</pre>
<p><a href="#sql_string">sql_string</a> returns <code>$string</code> surrounded by single quotes, and any single quote
in <code>$string</code> is doubled. If <code>$string</code> is <code>undef</code>, the string NULL (unquoted) is
returned. Example:</p>
<pre>
    print sql_string(&quot;This is Jim's house&quot;);
    print sql_string;</pre>
<p>prints</p>
<pre>
    'This is Jim''s house'
    NULL</pre>
<p>
</p>
<h2><a name="transaction_routines">Transaction routines</a></h2>
<pre>
    $X-&gt;sql_begin_trans;
    $X-&gt;sql_commit;
    $X-&gt;sql_rollback;</pre>
<p>These are just a short way of saying</p>
<pre>
    $X-&gt;sql(&quot;BEGIN TRANSACTION&quot;);
    $X-&gt;sql(&quot;COMMIT TRANSACTION&quot;);
    $X-&gt;sql(&quot;ROLLBACK TRANSACTION&quot;);</pre>
<p>respectively.</p>
<p>
</p>
<h2><a name="sql_set_conversion">sql_set_conversion</a></h2>
<pre>
    $X-&gt;sql_set_conversion([$client_cs [, $server_cs [, $direction]]]);</pre>
<p><strong>sql_set_conversion</strong> establishes a character conversion between client
and server and/or vice versa for the given handle. If you don't provide
a handle, the conversion is established for the handle returned by the
first call to <a href="#sql_init">sql_init</a>.</p>
<p>To start from the back, <strong>$direction</strong> specify in which direction you
want the conversion to apply. There are three possible values:</p>
<dl>
<dt><strong><a name="item_to_client_only">TO_CLIENT_ONLY</a></strong><br />
</dt>
<dd>
Convert only data that comes back from the server.
</dd>
<p></p>
<dt><strong><a name="item_to_server_only">TO_SERVER_ONLY</a></strong><br />
</dt>
<dd>
Convert only data that is sent to the server.
</dd>
<p></p>
<dt><strong><a name="item_to_server_client">TO_SERVER_CLIENT</a></strong><br />
</dt>
<dd>
Convert both when sending and receiving. This is the default.
</dd>
<p></p></dl>
<p><strong>$client_cs</strong> is the character set for the data on the client side, and
<strong>$server_cs</strong> is the character set for the data on the server side. The chosen
characters sets do not need to agree with the official character sets of the
client or the server.</p>
<p>Specify the character sets as code pages, with or without the leading ``CP''.
For <code>$client_cs</code> you can also specify ``OEM'' or ``ANSI'' to use the OEM or ANSI
character set of the client. These are read from the key
SYSTEM\CurrentControlSet\Control\Nls\CodePage in the HKEY_LOCAL_MACHINE hive.
For the server character set, you can specify ``iso_1'' as an alternative to
``CP1252'' to get Latin-1.</p>
<p>The default for <code>$client_cs</code> is the local OEM character set. The default for
<code>$server_cs</code> is the character set of the server (SQL7 and earlier) or the
default collation for the server (SQL2000 and later). (Use <em>sp_helpsort</em>
to find out if you don't know.)</p>
<p>To set up conversion <a href="#sql_set_conversion">sql_set_conversion</a> looks in the SYSTEM32 directory of
the NT installation as pointed to by the environment variable <em>SystemRoot</em>.
In this directory it looks for the file <em>SSSSCCCC</em>.CPX and if this fails an
attempt is made with <em>CCCCSSSS</em>.CPX . <em>SSSS</em> is the code-page number for the
server character set, and <em>CCCC</em> is the code-page number for the client
character set. For instance the file for converting to CP850 to Latin-1
(CP1252) is 12520850.CPX. If none of the files are found, execution is aborted.</p>
<p><strong>Notes:</strong></p>
<ul>
<li></li>
The conversion facility was added because SQL6.5 had insuffcient support
in this area. The GUI tools would unconditionally convert between ANSI
and OEM when reading and saving from disk. In other situations you could
not get the conversion you wanted. Tools in SQL7 improved in this area,
not the least BCP which offers the full range of choices just like
MSSQL::Sqllib. But OSQL in SQL7 could convert at all. OSQL in SQL2000
can, because you can now specify a data source. But you still can convert
to OEM if your data is ASCII and your server is OEM, because OSQL is an
OEM tool.
<p></p>
<li></li>
These character-set conversions typically are not fully round-trip. That is,
if you convert one character from set to another and back, you may not have
the same character you started with. This is because the character sets
contain different characters, and if a character is missing in the target
character set, it will be converted to some other character, for instance
the most similar-looking character.
<p></p>
<li></li>
You may think that the idea of a unidirectional conversion is funny, but say
that you have a table in which the data is the CP850 character set, and you
want it to be in Latin-1. This could be simple way of doing it:
<pre>
    use MSSQL::Sqllib(:DEFAULT :directions)</pre>
<pre>
    my $X = sql_init(undef, &quot;sa&quot;, &quot;&quot;, &quot;db&quot;);
    $X-&gt;sql_set_conversion(&quot;CP850&quot;, &quot;iso_1&quot;, TO_SERVER_ONLY);
    @table = $X-&gt;sql(&lt;&lt;SQLEND);
       SELECT * INTO #tbl FROM tbl WHERE 1 = 0  -- Clone the table.
       SELECT * FROM tbl
    SQLEND
    foreach $row (@table) {
       $X-&gt;sql_insert(&quot;#tbl&quot;, $row);
    }
    $X-&gt;sql(&lt;&lt;SQLEND);
       BEGIN TRANSCTION
       DELETE tbl
       INSERT tbl SELECT * FROM #tbl
       COMMIT TRANSACTION
    SQLEND</pre>
<p>Here we are converting the data as we send it back. Alternatively we could
have said:</p>
<pre>
    $X-&gt;sql_set_conversion(&quot;ANSI&quot;, &quot;CP850&quot;, TO_CLIENT_ONLY);</pre>
<p></p>
<li></li>
If the metadata names - names of tables, columns, stored procedures and their
parameters - contain characters that are subject to conversion, these names
are converted as well. Things <em>may</em> go well with bi-directional conversion.
With uni-directional conversion you are likely to run into trouble, and with
<a href="#sql_insert">sql_insert</a> and <a href="#sql_sp">sql_sp</a> you are almost bound to fail.
<p></p>
<li></li>
If you wish to have more specific conversion, for instance converting only
some characters (something you may want to do when you have a mix of character
sets in the database), compose your own CPX-file and put it in System32.
<p></p></ul>
<p>
</p>
<h2><a name="sql_unset_conversion">sql_unset_conversion</a></h2>
<pre>
    $X-&gt;sql_unset_conversion([$direction]);</pre>
<p>Removes any previous conversion in the given direction. If you leave out
<code>$direction</code>, conversion is removed in both directions. See
<a href="#sql_set_conversion">sql_set_conversion</a> for legal values of <code>$direction</code>.</p>
<p>If you don't provide a handle, the conversion is removed for the handle
returned by the first call to <a href="#sql_init">sql_init</a>.</p>
<p>
</p>
<h2><a name="sql_message_handler">sql_message_handler</a></h2>
<p>This routine is not exported, and thus not available by itself outside
MSSQL::Sqllib. However, as it is called time each time SQL Server sends a
message back to the client, its doings will still be of interest to you.</p>
<p>The behaviour of <a href="#sql_message_handler">sql_message_handler</a> is determined by the handle attribute
<a href="#errinfo">errInfo</a>, a hash which is described in detail separately in its own section.
Here I describe how <a href="#sql_message_handler">sql_message_handler</a> behaves with the default values of
<a href="#errinfo">errInfo</a> in force.</p>
<p>If the severity of the SQL Server message is &gt; 10, <a href="#sql_message_handler">sql_message_handler</a>
will set the <a href="#item_dieflag"><code>dieFlag</code></a> element of the <a href="#errinfo">errInfo</a> hash. If DB-Library
was called from within MSSQL::Sqllib, the calling routine will then
terminate execution. If you called DB-Library outside of MSSQL::Sqllib,
you need to look at <a href="#item_dieflag"><code>dieFlag</code></a> yourself.</p>
<p>This behaviour can be altered with the <a href="#errinfo">errInfo</a> elements <a href="#item_maxseverity"><code>maxSeverity</code></a>,
<a href="#item_alwaysstopon"><code>alwaysStopOn</code></a> and <a href="#item_neverstopon"><code>neverStopOn</code></a>. They permit you to choose a different
permitted severity level, and to specify exceptions for specific errors.</p>
<p>The message handler will also in its default configuration print a
message to STDERR. Here is a sample:</p>
<pre>
    SQL Server message 411, Severity 16, State 2, Server SOMMERSKOV
    Line 1
    Compute clause #2, aggregate expression #1 is not in the select list.
        1&gt; SELECT  dbid, segmap, lstart, size, vstart FROM sysusages
        2&gt; ORDER   BY dbid, segmap
        3&gt; COMPUTE sum(size) BY dbid, segmap
        4&gt; COMPUTE sum(2 * size) BY dbid
        5&gt; COMPUTE sum(size)</pre>
<p>Thus, you get both the error text as well as the code that caused the error.</p>
<p>If severity is 0 only the text part is printed. (That is <em>Compute clause...</em>
in the example above.)</p>
<p>Two messages are suppressed completely: the messages <em>Changed database context...</em>
and <em>Changed language setting...</em> On the other hand, the messages about arithmetic
overflow and division by zero are printed in full, even if they have severity 0.</p>
<p>You can change what is being printed with the <a href="#errinfo">errInfo</a> elements
<a href="#item_printmsg"><code>printMsg</code></a>, <a href="#item_printlines"><code>printLines</code></a>, <a href="#item_printtext"><code>printText</code></a>, <a href="#item_neverprint"><code>neverPrint</code></a> and <a href="#item_alwaysprint"><code>alwaysPrint</code></a>.</p>
<p>
</p>
<h2><a name="sql_error_handler">sql_error_handler</a></h2>
<p>Just like <a href="#sql_message_handler">sql_message_handler</a> this routine is not exported, but you can control
its behaviour by means of <a href="#errinfo">errInfo</a>. Here follows a description of the
default behaviour and a brief coverage of the control possibilities.</p>
<p><a href="#sql_error_handler">sql_error_handler</a> is called when DB-Library generates a message. If the
message has a severity level &gt; 1, <a href="#sql_error_handler">sql_error_handler</a> will set <a href="#item_dieflag"><code>dieFlag</code></a>,
and if DB-Library was called from MSSQL::DBlib, the execution will be aborted.
However, the error <em>General SQL Server error...</em> is ignored, as this always
is accompanied with a SQL Server error handled by <a href="#sql_message_handler">sql_message_handler</a>.</p>
<p>You can override this behaviour with the <a href="#errinfo">errInfo</a> elements <a href="#item_maxlibseverity"><code>maxLibSeverity</code></a>,
<a href="#item_neverstopon"><code>neverStopOn</code></a> and <a href="#item_alwaysstopon"><code>alwaysStopOn</code></a>.</p>
<p><a href="#sql_error_hanlder">sql_error_hanlder</a> prints all messages it receives, with the exception of
the aforementioned <em>General SQL Server error...</em> You can override this with
the <a href="#errinfo">errInfo</a> element <a href="#item_neverprint"><code>neverPrint</code></a>.</p>
<p>
</p>
<hr />
<h1><a name="handle_attributes">HANDLE ATTRIBUTES</a></h1>
<p>The attributes of MSSQL::DBlib is available with MSSQL::Sqllib as well. See
the section <a href="././mssql-dblib.html#handle_attributes">Handle Attributes in the mssql-dblib manpage</a> in the MSSQL::DBlib doc for
inforamtion on these attributes.</p>
<p>Here are the attributes specific to MSSQL::Sqllib.</p>
<p>
</p>
<h2><a name="misc_attributes">Misc attributes</a></h2>
<dl>
<dt><strong><a name="item_sql_version">SQL_version</a></strong><br />
</dt>
<dd>
This is a read-only attribute (well, nothing prevents you from changing it,
but if you do, please don't send me the error reports) that holds the
current SQL Server version. The is the version string that you see in
@@version, and also in <em>xp_msver</em>, for instance 8.00.194. (The release
version of SQL 2000.)
</dd>
<p></p>
<dt><strong><a name="item_loghandle">logHandle</a></strong><br />
</dt>
<dd>
When defined this should be an open filehandle to which all code you pass to
<a href="#sql">sql</a> and <a href="#sql_one">sql_one</a> is written, as well as the code generated by
<a href="#sql_insert">sql_insert</a> and <a href="#sql_sp">sql_sp</a>.
</dd>
<dd>
<p>The code is written after any client-to-server character-set conversion
has been applied.</p>
</dd>
<dd>
<p>Note that for <a href="#sql_sp">sql_sp</a> what you get is actually fake. <a href="#sql_sp">sql_sp</a> uses RPC
calls, so the EXEC statement you get in the log has never been executed. It
is nevertheless accurate, except that OUTPUT parameters are not marked as such.</p>
</dd>
<p></p>
<dt><strong><a name="item_noexec">noExec</a></strong><br />
</dt>
<dd>
Tells MSSQL::Sqllib to not execute the code it gets. This is useful in
combination with <a href="#item_loghandle"><code>logHandle</code></a> if all you want to do is to generate a script
that is to be run by <strong>isql</strong> later.
</dd>
<dd>
<p>Note that you still need to log into the server to use <a href="#item_noexec"><code>noExec</code></a>, and
<a href="#sql_insert">sql_insert</a> and <a href="#sql_sp">sql_sp</a> will still call the server to retrieve
information on table and procedures. Also <a href="#sql_set_conversion">sql_set_conversion</a> may call the
server.</p>
</dd>
<p></p>
<dt><strong><a name="item_procs">procs</a></strong><br />
</dt>
<dd>
This is a hash that <a href="#sql_sp">sql_sp</a> uses to cache parameter profiles. Normally you
have no reason to fiddle with this attribute, but if you have reason to believe
that a stored procedure has changed interface, since the last time you called
<a href="#sql_sp">sql_sp</a>, you can delete the SP from <a href="#item_procs"><code>procs</code></a>.
</dd>
<p></p>
<dt><strong><a name="item_tables">tables</a></strong><br />
</dt>
<dd>
This is a hash that <a href="#sql_insert">sql_insert</a> uses to cache table definitions. Normally you
have no reason to fiddle with this attribute, but if you have reason to believe
that a table has changed, since the last time you called <a href="#sql_insert">sql_insert</a>, you can delete
the table from <a href="#item_tables"><code>tables</code></a>.
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="errinfo">errInfo</a></h2>
<p>This attribute is a hash whose components are used by <a href="#sql_message_handler">sql_message_handler</a>,
<a href="#sql_error_handler">sql_error_handler</a> and <a href="#sql_sp">sql_sp</a> to determine whether to abort execution,
what and when to print and whether to return error messages to the caller.
Some of the components are arrays and hashes themselves. A pseudo-code
declaration with default values of <a href="#errinfo">errInfo</a> looks like this:</p>
<pre>
      RECORD errInfo
          -- Where to write error messages
          errFileHandle  IO::File = STDERR;</pre>
<pre>
          -- Abort control for sql_message_handler and sql_error_handler
          dieFlag        flag;
          maxSeverity    integer = 10;
          maxLibSeverity integer = 1;
          neverStopOn    HASH OF flags = {'-10007' =&gt; 1};
          alwaysStopOn   HASH OF flags = undef;</pre>
<pre>
          -- Print control for sql_messsage_handler and sql_error_handler
          printMsg     integer = 1;
          printText    integer = 0;
          printLines   integer = 11;
          neverPrint   HASH OF flags = {'5701' =&gt; 1, '5703' =&gt; 1, '-10007' =&gt; 1}
          alwaysPrint  HASH OF flags = {'3606' =&gt; 1, '3607' =&gt; 1, '3622' =&gt; 1}</pre>
<pre>
          -- Abort control for sql_sp
          checkRetStat flag = 1;
          retStatOK    HASH OF flags = undef;</pre>
<pre>
          -- Return error messages to caller
          saveMessages flag = 0;
          messages     ARRAY OF RECORD
                          state     integer;
                          errno     integer;
                          severity  integer;
                          text      string;
                          proc      string;
                          line      string;
                          oserr     integer;
                          oserrtext string;
                       END
      END</pre>
<p>In actual Perl code you would refer to an element in the <a href="#item_messages"><code>messages</code></a> array like this:</p>
<pre>
      $X-&gt;{errInfo}{'messages'}[0]{'errno'}</pre>
<p>This should give a clue on how to refer the other elements or <a href="#errinfo">errInfo</a> as
well.</p>
<p>Notice that you cannot use <a href="#errinfo">errInfo</a> to control the behaviour during <a href="#sql_init">sql_init</a>.</p>
<dl>
<dt><strong><a name="item_errfilehandle">errFileHandle</a></strong><br />
</dt>
<dd>
Where <a href="#sql_message_handler">sql_message_handler</a> and <a href="#sql_error_handler">sql_error_handler</a> are to write their
messages. Initially <code>undef</code>, which will cause the handlers to write to STDERR.
Set <a href="#item_errfilehandle"><code>errFileHandle</code></a> to a filehandle open for write to override this.
<a href="#item_errfilehandle"><code>errFileHandle</code></a> is useful, when you want to save SQL errors to a file,
but still want to see unexpected Perl warnings directly in the command window.
</dd>
<p></p>
<dt><strong><a name="item_dieflag">dieFlag</a></strong><br />
</dt>
<dd>
This is a read-only flag set by <a href="#sql_message_handler">sql_message_handler</a> or
<a href="#sql_error_handler">sql_error_handler</a>, suggesting the caller that execution is to be aborted.
If the caller is a routine in MSSQL::Sqllib, the advice is followed.
</dd>
<dd>
<p>MSSQL::Sqllib does not care about return status from DB-Library
calls, but rely exclusively on <a href="#item_dieflag"><code>dieFlag</code></a>. As long as you only call
MSSQL::Sqllib you have no reason to care about this flag. If you call
MSSQL::DBlib directly, but still rely on the handlers in MSSQL::Sqllib,
you can use <a href="#item_dieflag"><code>dieFlag</code></a> to determine whether to abort execution.</p>
</dd>
<p></p>
<dt><strong><a name="item_maxseverity">maxSeverity</a></strong><br />
</dt>
<dd>
The highest permitted severity level of messages from SQL Server.
<a href="#sql_message_handler">sql_message_handler</a> will set the <a href="#item_dieflag"><code>dieFlag</code></a> when receiving messsages
with severity above <a href="#item_maxseverity"><code>maxSeverity</code></a>. See also <a href="#item_neverstopon"><code>neverStopOn</code></a> and <a href="#item_alwaysstopon"><code>alwaysStopOn</code></a>.
Default: <strong>10</strong>.
</dd>
<dd>
<p>Note: it appears that SQL Server sends no messages with severities between
1 and 10, but in this case 0 is always used.</p>
</dd>
<p></p>
<dt><strong><a name="item_maxlibseverity">maxLibSeverity</a></strong><br />
</dt>
<dd>
The highest permitted severity level of messages from DB-Library.
<a href="#sql_error_handler">sql_error_handler</a> will set the <a href="#item_dieflag"><code>dieFlag</code></a> when receiving messsages
with severity above <a href="#item_maxlibseverity"><code>maxLibSeverity</code></a>. See also <a href="#item_neverstopon"><code>neverStopOn</code></a> and <a href="#item_alwaysstopon"><code>alwaysStopOn</code></a>
below. Default: <strong>1</strong> (= EXINFO).
</dd>
<dd>
<p>Constants for DB-Library severities are defined in MSSQL::DBlib::Const::Severity.</p>
</dd>
<p></p>
<dt><strong><a name="item_neverstopon">neverStopOn</a></strong><br />
</dt>
<dd>
This is a hash with error numbers as keys. <a href="#sql_message_handler">sql_message_handler</a> will never
set <a href="#item_dieflag"><code>dieFlag</code></a> for an error if <a href="#item_neverstopon"><code>neverStopOn</code></a><code>{$msgno}</code> is set. For DB-Library
errors, the error numbers are negated. Thus if <a href="#item_neverstopon"><code>neverStopOn</code></a><code>{-$dberr}</code> is set,
<a href="#sql_error_handler">sql_error_handler</a> will not set <a href="#item_dieflag"><code>dieFlag</code></a>. <a href="#item_neverstopon"><code>neverStopOn</code></a> overrides
<a href="#item_maxseverity"><code>maxSeverity</code></a> and <a href="#item_maxlibseverity"><code>maxLibSeverity</code></a>.
</dd>
<dd>
<p>Constants for DB-Library errors are defined in MSSQL::DBlib::Const::Errors.
If follows from the above that you must say:</p>
</dd>
<dd>
<pre>
    $sql-&gt;{errInfo}{neverStopOn}{-SQLECOFL()}</pre>
</dd>
<dd>
<p>to prevent the error <em>Data conversion resulted in overflow</em> causing <a href="#item_dieflag"><code>dieFlag</code></a>
to be set. (You must include the parentheses, or else Perl will interpret
<code>-SQLECOFL</code> as a bareword.)</p>
</dd>
<dd>
<p>By default, <a href="#item_neverstopon"><code>neverStopOn</code></a> includes one entry -10007 (-SQLEMSG). DB-Library
error 10007 is <em>General SQL Server error: Check messages from SQL server</em>.
This message is generated when SQL Server generates a messages with severity
11 or higher. As <a href="#sql_message_handler">sql_message_handler</a> takes care of these errors, 10007 is
exempted from handling in <a href="#sql_error_handler">sql_error_handler</a> for your convenience.</p>
</dd>
<p></p>
<dt><strong><a name="item_alwaysstopon">alwaysStopOn</a></strong><br />
</dt>
<dd>
This is a hash with error numbers as keys. <a href="#sql_message_handler">sql_message_handler</a> will always
set <a href="#item_dieflag"><code>dieFlag</code></a> for an error if <a href="#item_alwaysstopon"><code>alwaysStopOn</code></a><code>{$msgno}</code> is set. For DB-Library
errors, the error numbers are negated. Thus if <a href="#item_alwaysstopon"><code>alwaysStopOn</code></a><code>{-$dberr}</code> is set,
<a href="#sql_error_handler">sql_error_handler</a> will set <a href="#item_dieflag"><code>dieFlag</code></a>. <a href="#item_alwaysstopon"><code>alwaysStopOn</code></a> overrides <a href="#item_maxseverity"><code>maxSeverity</code></a>
and <a href="#item_maxlibseverity"><code>maxLibSeverity</code></a>.
</dd>
<dd>
<p>Empty by default.</p>
</dd>
<p></p>
<dt><strong><a name="item_printmsg">printMsg</a></strong><br />
</dt>
<dd>
Controls whether the message information from SQL Server is to be printed by
<a href="#sql_message_handler">sql_message_handler</a>. That is, this part:
</dd>
<dd>
<pre>
    SQL Server message 411, Severity 16, State 2, Server SOMMERSKOV
    Line 1</pre>
</dd>
<dd>
<p>The value of <a href="#item_printmsg"><code>printMsg</code></a> relates to a severity level, so that messages from
this severity and higher are printed. Default is <strong>1</strong>, the message
information are printed for all messages but PRINT statments, SHOWPLAN,
DBCC information and alike.</p>
</dd>
<dd>
<p>See also <a href="#item_neverprint"><code>neverPrint</code></a> and <a href="#item_alwaysprint"><code>alwaysPrint</code></a>.</p>
</dd>
<p></p>
<dt><strong><a name="item_printtext">printText</a></strong><br />
</dt>
<dd>
Controls whether the text portion of an SQL messages. The value of
<a href="#item_printtext"><code>printText</code></a> relates to a severity level, so that messages from this severity
and higher are printed. Default is 0, that is the text of all messages are
printed. However. blank lines are never printed.
</dd>
<dd>
<p>See also <a href="#item_neverprint"><code>neverPrint</code></a> and <a href="#item_alwaysprint"><code>alwaysPrint</code></a>.</p>
</dd>
<p></p>
<dt><strong><a name="item_printlines">printLines</a></strong><br />
</dt>
<dd>
Controls whether <a href="#sql_message_handler">sql_message_handler</a> is to print the lines of the
offending SQL. The value of <a href="#item_printlines"><code>printLines</code></a> relates to a severity level, so
that command lines from this severity and higher are printed. The default
is <strong>11</strong>, the lowest level for error messages.
</dd>
<dd>
<p>See also <a href="#item_neverprint"><code>neverPrint</code></a> and <a href="#item_alwaysprint"><code>alwaysPrint</code></a>.</p>
</dd>
<p></p>
<dt><strong><a name="item_neverprint">neverPrint</a></strong><br />
</dt>
<dd>
This is a hash with error numbers as keys. If <a href="#item_neverprint"><code>neverPrint</code></a><code>{$msgno}</code> has a
true value, <a href="#sql_message_handler">sql_message_handler</a> will print no part of the message
regardless of <a href="#item_printmsg"><code>printMsg</code></a>, <a href="#item_printtext"><code>printText</code></a> and <a href="#item_printlines"><code>printLines</code></a>.
</dd>
<dd>
<p>Likewise <a href="#sql_error_handler">sql_error_handler</a> will not print a messages if <a href="#item_neverprint"><code>neverPrint</code></a><code>{-$dberr}</code>
is set. That is, DB-Library error codes should appear with a negative value.</p>
</dd>
<dd>
<p>By default the following entires are set: 5701, 5703 and -10007. 5701 is
<em>Changed database context...</em> and 5703 is <em>Changed language setting...</em>.
These messages are generated on every login, and you rarely want to see them.
See <a href="#item_neverstopon"><code>neverStopOn</code></a> for a discussion on DB-Library message 10007.</p>
</dd>
<p></p>
<dt><strong><a name="item_alwaysprint">alwaysPrint</a></strong><br />
</dt>
<dd>
This is a hash with error numbers as keys. If <a href="#item_alwaysprint"><code>alwaysPrint</code></a><code>{$errno}</code> has
a true value, <a href="#sql_message_handler">sql_message_handler</a> will print all parts of the message
regardless of <a href="#item_printmsg"><code>printMsg</code></a>, <a href="#item_printtext"><code>printText</code></a> and <a href="#item_printlines"><code>printLines</code></a>. By the default
the messages 3606, 3607 are flagged. 3606 is <em>Arithmetic overflow
occurred</em>, 3607 is <em>Division by zero occurred</em> and 3622 is
<em>A domain error occurred</em>. These are raised with severity 0 if you have
set none of ARITHABORT or ARITHIGNORE ON. At least this SQL programmer
feels that he wants to know on where the problem occurred, even if he
didn't think of setting ARITHABORT.
</dd>
<dd>
<p>This hash is not applicable to <a href="#sql_error_handler">sql_error_handler</a>.</p>
</dd>
<p></p>
<dt><strong><a name="item_checkretstat">checkRetStat</a></strong><br />
</dt>
<dd>
Determines whether <a href="#sql_sp">sql_sp</a> is to check return status of the stored
procedures it calls. The default it is <strong>1</strong>. Unset it, to have <a href="#sql_sp">sql_sp</a> to
permit any return values.
</dd>
<p></p>
<dt><strong><a name="item_retstatok">retStatOK</a></strong><br />
</dt>
<dd>
This is a hash with permissible return values as keys. The values of
the keys must have a true values. For instance if you say
</dd>
<dd>
<pre>
    $X-&gt;{errInfo}{retStatOK}{'4711'}++;</pre>
</dd>
<dd>
<p><a href="#sql_sp">sql_sp</a> will accept 4711 as a return status without aborting even
when <a href="#item_checkretstat"><code>checkRetStat</code></a> is in effect. Default: empty.</p>
</dd>
<p></p>
<dt><strong><a name="item_savemessages">saveMessages</a></strong><br />
</dt>
<dd>
If you set this flag, <a href="#sql_message_handler">sql_message_handler</a> will save the messages from
SQL Server in the array <a href="#item_messages"><code>messages</code></a>. By default this flag is off.
</dd>
<p></p>
<dt><strong><a name="item_messages">messages</a></strong><br />
</dt>
<dd>
This is an array of hashes, each hash containing one message, using the
following keys:
</dd>
<dd>
<pre>
    state     - the state of the messages. -1 means that the message
                comes from DB-Library.
    errno     - the number of the SQL message or the DB-Library message.
                (No negation of DB-Library error numbers are performed.)
    severity  - the severity of the message.
    text      - the text of the message.
    proc      - the procedure involved in the error.
    line      - the number of the line in the procedure/batch in which
                the error occurred.
    oserr     - error code from the operating system, only applicable to
                certain DB-Library errors.
    oserrtext - error text accompanying oserr, if any.</pre>
</dd>
<dd>
<p>The hashes are added at the end of the array by <a href="#sql_message_handler">sql_message_handler</a> and
<a href="#sql_error_handler">sql_error_handler</a> when <a href="#item_savemessages"><code>saveMessages</code></a> is set. No routine in MSSQL::Sqllib
ever deletes anything from <a href="#item_messages"><code>messages</code></a>.</p>
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><a name="restrictions_with_new_datatypes">Restrictions with new datatypes</a></h1>
<p>With MS SQL Server 7, Microsoft abadoned further development of DB-Library, on
which MSSQL::Sqllib is based, including adaptions to new features in SQL Server.</p>
<p>The area where is most likely to give cause for concern is new and enhanced
datatype. You can always pass a new or enhanced datatype as part of a command
string (save the fact that MSSQL::Sqllib cannot handle Unicode data), but
you run into to problems if you want to use them as a parameter to a stored
procedure, or get them back in a result set. This is a list over known issues.</p>
<dl>
<dt><strong><a name="item_bigint">bigint</a></strong><br />
</dt>
<dd>
This datatype was added in SQL 2000. These values are passed as floats
between SQL Server to DB-Library. In practice this means that you can use
integers with 14-15 digits of accuracy.
</dd>
<p></p>
<dt><strong><a name="item_bit">bit</a></strong><br />
</dt>
<dd>
SQL 7 introduced nullable bit columns. If you retrieve a bit value with
the value NULL, it will appear as 0 in DB-Library, not as <code>undef</code>. The same
applies if you attempt to pass <code>undef</code> for a bit parameter with <a href="#sql_sp">sql_sp</a>.
</dd>
<p></p>
<dt><strong><a name="item_char_and_varchar">char and varchar</a></strong><br />
</dt>
<dd>
SQL 7 increased the maximum length for char and varchar values
from 255 characters to 8000. With MSSQL::Sqllib values longer than 255
characters will be truncated, both in result sets, and when passing
parameters with <a href="#sql_sp">sql_sp</a>.
</dd>
<dd>
<p>SQL 7 introduced the empty string as a possible varchar value. These will
appear as strings of one blank in MSSQL::Sqllib. If you attempt to pass the empty
string as a parameter value, it will be converted to one blank before being
passed to SQL Server.</p>
</dd>
<p></p>
<dt><strong><a name="item_nchar_and_nvarchar">nchar and nvarchar</a></strong><br />
</dt>
<dd>
These datatypes were introduced in SQL 7 to support Unicode data.
For DB-Library they appear just as char/varchar data, and long values
will be truncated after 255 characters. Characters outside the range of
0-255 are converted to some fallback character by SQL Server.
</dd>
<p></p>
<dt><strong><a name="item_ntext">ntext</a></strong><br />
</dt>
<dd>
This datatype is not supported at all. SQL Server refuses to return ntext
values to legacy clients such as DB-Library.
</dd>
<p></p>
<dt><strong><a name="item_binary_and_varbinary">binary and varbinary</a></strong><br />
</dt>
<dd>
Restrictions analogous to those for char and varchar apply.
</dd>
<p></p>
<dt><strong><a name="item_uniqueidentifier">uniqueidentifier</a></strong><br />
</dt>
<dd>
When you retrieve such a value in a result set, you will receive the value in a
hex string where the bytes have been tossed around. You can use the MSSQL::DBlib
function <a href="#reformat_uniqueid">reformat_uniqueid</a> to get a properly formatted GUID string.
</dd>
<dd>
<p>You can however successfully pass a regular GUID string (e.g.
``7223C906-2CF2-11D0-AFB8-00A024A82C78'' to a uniqueidentifier parameter, and
you can also retrieve a properly formatted GUID string back from an
OUTPUT parameter.</p>
</dd>
<p></p>
<dt><strong><a name="item_sql_variant">sql_variant</a></strong><br />
</dt>
<dd>
This datatype was introduced in SQL 2000. All sql_variant data will be passed as
char values to DB-Library clients, and all data you enter through <a href="#sql_sp">sql_sp</a>
will have a base type of varchar.
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><a name="acknowledgements">ACKNOWLEDGEMENTS</a></h1>
<p>Michael Peppler included the <code>&amp;sql</code> routine in his Sybperl, a contribution he
credits to Gisele Aas. This was the feather from which the Sqllib bird was
born.</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Erland Sommarskog  &lt;<em>sommar<code>@algonet</code>.se</em>&gt;.</p>

</body>

</html>
